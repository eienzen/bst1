<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BlockSnakes Game</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        canvas {
            border: 2px solid #000;
            display: block;
            margin: 0 auto;
        }
        .controls {
            text-align: center;
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
        }
        @media (max-width: 600px) {
            canvas {
                width: 90vw !important;
                height: auto !important;
            }
        }
    </style>
</head>
<body>
    <div id="gameCanvas"></div>
    <div class="controls">
        <button onclick="startGame()">Start Game</button>
        <button onclick="claimWelcomeBonus()">Claim Welcome Bonus</button>
        <button onclick="convertPoints()">Convert Points</button>
        <button onclick="stakeTokens()">Stake Tokens</button>
        <button onclick="unstakeTokens()">Unstake Tokens</button>
        <button onclick="mintTokens()">Mint Tokens (Owner)</button>
        <button onclick="burnTokens()">Burn Tokens (Owner)</button>
        <button onclick="updateGameOracle()">Update Game Oracle (Owner)</button>
    </div>

    <script>
        let snake, food, score, gameState;
        const gridSize = 20;
        const canvasSize = 400;
        const contractAddress = "0x4fe4bF5670405772941d0D1e5706863A13f17B28";
        const abi = [/* Your ABI here */];
        let web3, contract, accounts;

        // Initialize Web3 and Contract
        async function initWeb3() {
            if (window.ethereum) {
                web3 = new Web3(window.ethereum);
                await window.ethereum.request({ method: "eth_requestAccounts" });
                accounts = await web3.eth.getAccounts();
                contract = new web3.eth.Contract(abi, contractAddress);
            } else {
                alert("Please install MetaMask!");
            }
        }

        // p5.js Setup
        function setup() {
            let canvas = createCanvas(canvasSize, canvasSize);
            canvas.parent("gameCanvas");
            frameRate(10);
            resetGame();
        }

        function draw() {
            background(220);
            if (gameState === "playing") {
                updateGame();
                drawGame();
            }
        }

        function resetGame() {
            snake = [{ x: 10, y: 10 }];
            food = { x: floor(random(0, canvasSize / gridSize)), y: floor(random(0, canvasSize / gridSize)) };
            score = 0;
            gameState = "playing";
        }

        function updateGame() {
            const head = { x: snake[0].x, y: snake[0].y };
            if (keyIsDown(LEFT_ARROW)) head.x -= 1;
            if (keyIsDown(RIGHT_ARROW)) head.x += 1;
            if (keyIsDown(UP_ARROW)) head.y -= 1;
            if (keyIsDown(DOWN_ARROW)) head.y += 1;

            head.x = (head.x + canvasSize / gridSize) % (canvasSize / gridSize);
            head.y = (head.y + canvasSize / gridSize) % (canvasSize / gridSize);

            if (head.x === food.x && head.y === food.y) {
                score += 10;
                food = { x: floor(random(0, canvasSize / gridSize)), y: floor(random(0, canvasSize / gridSize)) };
            } else {
                snake.pop();
            }
            snake.unshift(head);

            if (snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y)) {
                gameState = "over";
            }
        }

        function drawGame() {
            // Draw Snake with Eyes and Body
            fill(0, 255, 0); // Green body
            for (let i = 0; i < snake.length; i++) {
                rect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize - 2, gridSize - 2, 5);
                if (i === 0) {
                    // Draw Eyes
                    fill(255); // White eyes
                    ellipse(snake[i].x * gridSize + 4, snake[i].y * gridSize + 4, 4, 4);
                    ellipse(snake[i].x * gridSize + 12, snake[i].y * gridSize + 4, 4, 4);
                    fill(0); // Black pupils
                    ellipse(snake[i].x * gridSize + 4, snake[i].y * gridSize + 4, 2, 2);
                    ellipse(snake[i].x * gridSize + 12, snake[i].y * gridSize + 4, 2, 2);
                }
            }

            // Draw Food
            fill(255, 0, 0); // Red food
            rect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2, 5);

            // Draw Score
            fill(0);
            textSize(16);
            text(`Score: ${score}`, 10, 20);
        }

        // Game Controls
        function startGame() {
            resetGame();
        }

        async function claimWelcomeBonus() {
            await contract.methods.claimWelcomeBonus().send({ from: accounts[0] });
            alert("Welcome bonus claimed!");
        }

        async function convertPoints() {
            const points = parseInt(prompt("Enter points to convert:"));
            const referrer = prompt("Enter referrer address (optional):") || "0x0000000000000000000000000000000000000000";
            await contract.methods.convertPointsToTokens(points, accounts[0], referrer).send({ from: accounts[0], value: web3.utils.toWei("0.0002", "ether") });
            alert("Points converted to tokens!");
        }

        async function stakeTokens() {
            const amount = parseInt(prompt("Enter amount to stake:"));
            const lockPeriod = parseInt(prompt("Enter lock period (0: Flexible, 1: 60 Days, 2: 180 Days, 3: 365 Days):"));
            await contract.methods.stakeTokens(amount, lockPeriod).send({ from: accounts[0] });
            alert("Tokens staked!");
        }

        async function unstakeTokens() {
            const amount = parseInt(prompt("Enter amount to unstake:"));
            const lockPeriod = parseInt(prompt("Enter lock period (0: Flexible, 1: 60 Days, 2: 180 Days, 3: 365 Days):"));
            await contract.methods.unstakeTokens(amount, lockPeriod).send({ from: accounts[0] });
            alert("Tokens unstaked!");
        }

        async function mintTokens() {
            const amount = parseInt(prompt("Enter amount to mint:"));
            const key = prompt("Enter secret key:");
            await contract.methods.mintTokens(amount, key).send({ from: accounts[0] });
            alert("Tokens minted!");
        }

        async function burnTokens() {
            const amount = parseInt(prompt("Enter amount to burn:"));
            const key = prompt("Enter secret key:");
            await contract.methods.burnTokens(amount, key).send({ from: accounts[0] });
            alert("Tokens burned!");
        }

        async function updateGameOracle() {
            const newOracle = prompt("Enter new oracle address:");
            const key = prompt("Enter secret key:");
            await contract.methods.updateGameOracle(newOracle, key).send({ from: accounts[0] });
            alert("Game oracle updated!");
        }

        // Initialize on load
        window.onload = async () => {
            await initWeb3();
        };
    </script>
</body>
</html>
